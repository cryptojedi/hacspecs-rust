// // Import hacspec and all needed definitions.
// use hacspec::prelude::*;

// use crate::sha2;

// const HASH_LEN: usize = sha2::HASH_SIZE;
// bytes!(PRK, HASH_LEN);

// // HMAC
// const BLOCK_LEN: usize = sha2::K_SIZE;
// bytes!(Block, BLOCK_LEN);

// // H(K XOR opad, H(K XOR ipad, text))
// pub fn hmac(k: Bytes, txt: Bytes) -> PRK {
//     let i_pad: Block = Block::from([0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36,0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36]);
//     let o_pad: Block = Block::from([0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c,0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c, 0x5c]);
    
//     // Applications that use keys longer than B bytes will first hash the key using H and then use the resultant L byte string as the actual key to HMAC
//     let k_block = if k.len() > BLOCK_LEN {
//         sha2::hash(k.get_slice()).raw().into()
//     } else {
//         Block::from_vlbytes_lazy(k)
//     };

//     let k_ipad = k_block ^ i_pad;
//     let k_opad = k_block ^ o_pad;

//     let mut h_in = Bytes::new();
//     h_in.extend_from_slice(k_ipad.raw());
//     h_in.extend(txt);
//     let h_inner = sha2::hash(h_in.get_slice());

//     let mut h_in = Bytes::new();
//     h_in.extend_from_slice(k_opad.raw());
//     h_in.extend_from_slice(h_inner.raw());
//     sha2::hash(h_in.get_slice()).raw().into()
// }
